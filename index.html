<!DOCTYPE html>
<html>
<head>
    <title>Steep Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #race-info {
            position: fixed;
            left: 20px;
            top: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            font-size: 24px;
        }
        #score {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 24px;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="race-info">
        <div>Time: <span id="race-time">00:00.000</span></div>
        <div>Best: <span id="best-time">00:37.993</span></div>
    </div>
    <div id="score">Score: 0</div>
    <div id="controls">
        WASD - Move | SPACE - Jump | SHIFT - Crouch | ARROWS - Tricks
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.162.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        class SteepClone {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.FogExp2(0x87CEEB, 0.001);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                this.startTime = Date.now();
                this.score = 0;
                this.raceStarted = false;

                this.player = {
                    position: new THREE.Vector3(0, 50, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Euler(0, 0, 0),
                    speed: 0,
                    isGrounded: false
                };

                this.tricks = {
                    isInAir: false,
                    rotationX: 0,
                    rotationZ: 0,
                    grab: false
                };

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.init();
            }

            init() {
                // Create terrain
                const terrainGeometry = new THREE.PlaneGeometry(1000, 2000, 100, 200);
                const vertices = terrainGeometry.attributes.position.array;

                // Generate realistic mountain terrain
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 2];
                    
                    let height = Math.sin(x * 0.02) * 50 + Math.cos(z * 0.02) * 50;
                    
                    // Add race track depression
                    const trackWidth = 20;
                    const distanceFromTrack = Math.abs(x);
                    if (distanceFromTrack < trackWidth) {
                        height *= 0.5;
                    }
                    
                    // Add jumps
                    const jumpLocations = [-200, -400, -600, -800];
                    jumpLocations.forEach(loc => {
                        if (z > loc - 10 && z < loc + 10 && Math.abs(x) < trackWidth) {
                            height += 15 * Math.exp(-(Math.pow(z - loc, 2) / 50));
                        }
                    });
                    
                    vertices[i + 1] = height;
                }

                terrainGeometry.computeVertexNormals();
                
                const snowTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
                snowTexture.wrapS = snowTexture.wrapT = THREE.RepeatWrapping;
                snowTexture.repeat.set(50, 50);

                const terrainMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    map: snowTexture,
                    shininess: 30,
                    specular: 0x333333
                });

                this.terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                this.terrain.rotation.x = -Math.PI / 3;
                this.terrain.receiveShadow = true;
                this.scene.add(this.terrain);

                // Create skier character
                this.playerGroup = new THREE.Group();

                // Body (yellow jacket)
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.7);
                const jacketMaterial = new THREE.MeshPhongMaterial({ color: 0xFFAA00 }); // Yellow jacket
                const body = new THREE.Mesh(bodyGeometry, jacketMaterial);
                body.position.y = 1.5;
                this.playerGroup.add(body);

                // Head with helmet
                const helmetGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const helmetMaterial = new THREE.MeshPhongMaterial({ color: 0x00AA00 }); // Green helmet
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 2.5;
                this.playerGroup.add(helmet);

                // Goggles
                const gogglesGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.1);
                const gogglesMaterial = new THREE.MeshPhongMaterial({ color: 0x3366ff });
                const goggles = new THREE.Mesh(gogglesGeometry, gogglesMaterial);
                goggles.position.y = 2.5;
                goggles.position.z = 0.2;
                this.playerGroup.add(goggles);

                // Skis
                const skiGeometry = new THREE.BoxGeometry(0.2, 0.1, 2);
                const skiMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                
                const leftSki = new THREE.Mesh(skiGeometry, skiMaterial);
                leftSki.position.set(-0.3, 0, 0);
                this.playerGroup.add(leftSki);

                const rightSki = new THREE.Mesh(skiGeometry, skiMaterial);
                rightSki.position.set(0.3, 0, 0);
                this.playerGroup.add(rightSki);

                // Poles
                const poleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.4);
                const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                
                const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
                leftPole.position.set(-0.6, 1.2, 0.3);
                this.playerGroup.add(leftPole);

                const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
                rightPole.position.set(0.6, 1.2, 0.3);
                this.playerGroup.add(rightPole);

                // Add race gates
                this.addRaceGates();

                // Add trees
                this.addTrees();

                this.scene.add(this.playerGroup);
                this.playerMesh = this.playerGroup;

                // Lighting
                const sun = new THREE.DirectionalLight(0xffffff, 1);
                sun.position.set(100, 100, 0);
                sun.castShadow = true;
                this.scene.add(sun);
                this.scene.add(new THREE.AmbientLight(0x404040));

                // Add mountains
                this.addMountains();

                this.setupControls();
                this.animate();
            }

            addRaceGates() {
                const gateGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const gateMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                
                for(let i = 0; i < 20; i++) {
                    const leftGate = new THREE.Mesh(gateGeometry, gateMaterial);
                    const rightGate = new THREE.Mesh(gateGeometry, gateMaterial);
                    
                    leftGate.position.set(-5, 2, -i * 50);
                    rightGate.position.set(5, 2, -i * 50);
                    
                    this.scene.add(leftGate);
                    this.scene.add(rightGate);
                }
            }

            addTrees() {
                const treeGeometry = new THREE.ConeGeometry(2, 5);
                const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x005500 });
                
                for(let i = 0; i < 200; i++) {
                    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                    const x = Math.random() * 400 - 200;
                    const z = Math.random() * 1000 - 500;
                    
                    if(Math.abs(x) > 10) {
                        tree.position.set(x, 2, z);
                        this.scene.add(tree);
                    }
                }
            }

            addMountains() {
                const mountainGeometry = new THREE.ConeGeometry(100, 200, 4);
                const mountainMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                
                for(let i = 0; i < 10; i++) {
                    const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                    mountain.position.set(
                        Math.random() * 1000 - 500,
                        -50,
                        Math.random() * -1000 - 500
                    );
                    mountain.scale.set(
                        1 + Math.random() * 2,
                        1 + Math.random() * 2,
                        1 + Math.random() * 2
                    );
                    this.scene.add(mountain);
                }
            }

            setupControls() {
                this.keys = {
                    left: false,
                    right: false,
                    up: false,
                    down: false,
                    space: false,
                    shift: false,
                    arrowLeft: false,
                    arrowRight: false,
                    arrowUp: false,
                    arrowDown: false
                };

                window.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'a': this.keys.left = true; break;
                        case 'd': this.keys.right = true; break;
                        case 'w': this.keys.up = true; break;
                        case 's': this.keys.down = true; break;
                        case ' ': this.keys.space = true; break;
                        case 'shift': this.keys.shift = true; break;
                        case 'arrowleft': this.keys.arrowLeft = true; break;
                        case 'arrowright': this.keys.arrowRight = true; break;
                        case 'arrowup': this.keys.arrowUp = true; break;
                        case 'arrowdown': this.keys.arrowDown = true; break;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'a': this.keys.left = false; break;
                        case 'd': this.keys.right = false; break;
                        case 'w': this.keys.up = false; break;
                        case 's': this.keys.down = false; break;
                        case ' ': this.keys.space = false; break;
                        case 'shift': this.keys.shift = false; break;
                        case 'arrowleft': this.keys.arrowLeft = false; break;
                        case 'arrowright': this.keys.arrowRight = false; break;
                        case 'arrowup': this.keys.arrowUp = false; break;
                        case 'arrowdown': this.keys.arrowDown = false; break;
                    }
                });
            }

            updateRaceTime() {
                if (!this.raceStarted) return;
                
                const currentTime = Date.now();
                const elapsedTime = currentTime - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const milliseconds = elapsedTime % 1000;
                
                document.getElementById('race-time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }

            updatePlayer(delta) {
                const GRAVITY = 9.8;
                const JUMP_FORCE = 15;
                const TURN_SPEED = 2;
                const MAX_SPEED = 40;
                const ACCELERATION = 15;

                if (!this.raceStarted && this.player.speed > 0) {
                    this.raceStarted = true;
                    this.startTime = Date.now();
                }

                // Apply gravity
                if (!this.player.isGrounded) {
                    this.player.velocity.y -= GRAVITY * delta;
                }

                // Jumping
                if (this.keys.space && this.player.isGrounded) {
                    this.player.velocity.y = JUMP_FORCE;
                    this.player.isGrounded = false;
                    this.tricks.isInAir = true;
                }

                // Movement
                if (this.keys.left) this.player.rotation.y += TURN_SPEED * delta;
                if (this.keys.right) this.player.rotation.y -= TURN_SPEED * delta;
                if (this.keys.up) this.player.speed = Math.min(this.player.speed + ACCELERATION * delta, MAX_SPEED);
                if (this.keys.down) this.player.speed = Math.max(this.player.speed - ACCELERATION * delta, 0);

                // Tricks
                if (this.tricks.isInAir) {
                    if (this.keys.arrowLeft) this.tricks.rotationZ += 5 * delta;
                    if (this.keys.arrowRight) this.tricks.rotationZ -= 5 * delta;
                    if (this.keys.arrowUp) this.tricks.rotationX += 5 * delta;
                    if (this.keys.arrowDown) this.tricks.rotationX -= 5 * delta;
                    if (this.keys.shift) this.tricks.grab = true;

                    this.playerMesh.rotation.z = this.tricks.rotationZ;
                    this.playerMesh.rotation.x = this.tricks.rotationX;

                    if (Math.abs(this.tricks.rotationZ) > Math.PI * 2) {
                        this.score += 100;
                        this.updateScore();
                    }
                    if (Math.abs(this.tricks.rotationX) > Math.PI) {
                        this.score += 150;
                        this.updateScore();
                    }
                    if (this.tricks.grab) {
                        this.score += 50;
                        this.updateScore();
                    }
                }

                // Update position
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyEuler(this.player.rotation);
                this.player.position.add(direction.multiplyScalar(this.player.speed * delta));
                this.player.position.add(this.player.velocity.clone().multiplyScalar(delta));

                // Ground check
                if (this.player.position.y < 2) {
                    this.player.position.y = 2;
                    this.player.velocity.y = 0;
                    this.player.isGrounded = true;

                    if (this.tricks.isInAir) {
                        this.tricks.isInAir = false;
                        this.tricks.rotationX = 0;
                        this.tricks.rotationZ = 0;
                        this.tricks.grab = false;
                        this.playerMesh.rotation.set(0, this.player.rotation.y, 0);
                    }
                }

                // Update mesh position
                this.playerMesh.position.copy(this.player.position);
                this.playerMesh.rotation.y = this.player.rotation.y;

                // Animate skiing
                this.animateSkiing(delta);

                // Update camera - more dynamic following
                const cameraOffset = new THREE.Vector3(
                    0,
                    3 + (this.player.speed / MAX_SPEED) * 2,
                    8 + (this.player.speed / MAX_SPEED) * 4
                );
                cameraOffset.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                this.camera.position.copy(this.player.position).add(cameraOffset);
                this.camera.lookAt(this.player.position);
            }

            animateSkiing(delta) {
                if (this.player.speed > 0) {
                    const poleSwing = Math.sin(Date.now() * 0.01) * 0.2;
                    this.playerGroup.children.forEach(child => {
                        if (child.position.x === -0.6 || child.position.x === 0.6) {
                            child.rotation.x = poleSwing;
                        }
                    });

                    const speedLean = Math.min(this.player.speed / 40, 0.3);
                    this.playerGroup.rotation.x = speedLean;
                }

                const turnLean = this.keys.left ? 0.2 : this.keys.right ? -0.2 : 0;
                this.playerGroup.rotation.z = turnLean;

                if (this.keys.shift) {
                    this.playerGroup.scale.y = 0.8;
                } else {
                    this.playerGroup.scale.y = 1;
                }
            }

            updateScore() {
                document.getElementById('score').textContent = `Score: ${this.score}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updatePlayer(1/60);
                this.updateRaceTime();
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => {
            new SteepClone();
        };
    </script>
</body>
</html>
